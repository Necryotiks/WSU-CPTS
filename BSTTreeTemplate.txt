BSTList<T> OBJ;

template <class T>
class BSTList
{
public:
	BSTList();
	~BSTList();

	void BSTPrint();
	void BSTDeleteTree();

	std::shared_ptr<BSTNode<T>>& getRoot();

	void setRoot(std::shared_ptr<BSTNode<T>> const newRoot);
	void insert(std::shared_ptr<BSTNode<T>>&Node);
	//needs node data collection

	static std::shared_ptr<BSTNode<T>> makeNode();
private:
	std::shared_ptr<BSTNode<T>> rootNode;
	void insert(std::shared_ptr<BSTNode<T>>&rootNode, std::shared_ptr<BSTNode<T>>& Node); 
	void BSTPrint(std::shared_ptr<BSTNode<T>>&rootNode);
	void BSTDeleteTree(std::shared_ptr<BSTNode<T>>& rootNode);
};

template<class T>
BSTList<T>::BSTList()
{
//put list construction here...or not.
}

template<class T>
BSTList<T>::~BSTList()
{
	BSTDeleteTree();
	cout << "Tree deconstructed" << endl;
}

template<class T>
void BSTList<T>::BSTPrint()
{
	BSTPrint(this->rootNode);
}

template<class T>
void BSTList<T>::BSTDeleteTree()
{
	BSTDeleteTree(this->rootNode);
}

template<class T>
BSTNode<T>*& BSTList<T>::getRoot()
{
	return rootNode;
}

template<class T>
void BSTList<T>::setRootstd::shared_ptr<BSTNode<T>> const newRoot)
{
	rootNode = newRoot;
}

template<class T>
void BSTList<T>::insert(std::shared_ptr<BSTNode<T>>& Node)
{
	insert(this->rootNode, Node);
}

template<class T>
std::shared_ptr<BSTNode<T>> BSTList<T>::makeNode()
{
	return std::shared_ptr<BSTNode<T>> (new BSTNode);
}

template<class T>
void BSTList<T>::insert(std::shared_ptr<BSTNode<T>>& rootNode, std::shared_ptr<BSTNode<T>>& Node)
{
	if (rootNode == nullptr)
	{
		rootNode = Node;
	}
	else if (Node->getData() < rootNode->getData())
	{
		insert(rootNode->getLeft(), Node);
	}
	else if (Node->getData() > rootNode->getData())
	{
		insert(rootNode->getRight(), Node);
	}
	else
	{
		cout << "duplicate" << endl;
	}
}

template<class T>
void BSTList<T>::BSTPrint(std::shared_ptr<BSTNode<T>>&rootNode)//in order print.
{
	if (rootNode != nullptr)
	{
		BSTPrint(rootNode->getLeft());
		//print something
		BSTPrint(rootNode->getRight());

	}
}
template<class T>
void BSTList<T>::BSTDeleteTree(std::shared_ptr<BSTNode<T>>& rootNode)
{
	if (rootNode != nullptr)
	{
		BSTDeleteTree(rootNode->getLeft());
		BSTDeleteTree(rootNode->getRight());//delete at bottom instead of mid inorder to travers the whole tree.
		delete rootNode;
	}
}
//BST tree template
//Needs BST node template to function
//All that is needed is data collection loop for node.
//Code: Andy O'Fallon
//Template w/ additions: Elliott Villars
